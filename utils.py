from natsort import natsorted
from re import split, compile, search
# Console
from tkinter import NORMAL, DISABLED
from datetime import datetime

# Get an element from an array/dictionary. Return a default value if empty or element does not exist
def get_element(array, element, default_value=""):
    # For arrays
    if type(array) is list:
        if element >= len(array):
            return default_value
        
        result = array[element]
        if result == "":
            return default_value
        else:
            return result
        
    # For dictionaries
    elif type(array) is dict:
        if element in array:
            result = array[element]
            if result == "":
                return default_value
            else:
                return result
        else:
            return default_value

class Console:
    def __init__(self, console, window):
        self.console = console
        self.window  = window

    ## Write message to the console
    def write(self, message):
        if not message=="":
            self.console.configure(state = NORMAL)
            self.console.insert("end", datetime.now().strftime("%d-%m-%Y %H:%M:%S") + " - " + message.rstrip() + "\n")
            self.console.configure(state = DISABLED)
            self.console.see("end")
        self.window.update()
        self.window.update_idletasks()

## CPE version matcher    
class VersionMatcher:
    def __init__(self, version):
        self.version = str(version)
        
    def __empty(self, value):
        return value == ""
        
    def __eqIgnoreTrailingZeros(self, right):
        left_trimmed = self.version
        while left_trimmed.endswith(".0"):
            left_trimmed = left_trimmed[:-2]

        right_trimmed = right
        while right_trimmed.endswith(".0"):
            right_trimmed = right_trimmed[:-2]

        return left_trimmed == right_trimmed
        
    def __eq(self, right):
        left = self.version
        return left == right or self.__eqIgnoreTrailingZeros(right)

    def __like(self, right):
        left = self.version
        left = left.replace(".", "\.")
        left = left.replace("*", ".*")
        regex = compile("^"+left)
        #print(search(regex, right))
        return regex.match(right) is not None
       
    def __lt(self, right):
        left = self.version
        if self.__eq(right):
            return False
        elif self.__like(right):
            return True

        ns = natsorted([left, right])
        return self.__empty(right) or self.__eq(ns[0])

    def __gt(self, right):
        left = self.version
        if self.__eq(right):
            return False
        elif self.__like(right):
            return True
            
        ns = natsorted([left, right])
        return self.__empty(right) or self.__eq(ns[1])

    def __le__(self, right):
        return self.__eq(right) or self.__lt(right)

    def __ge(self, right):
        return self.__eq(right) or self.__gt(right)
    
    def __str__(self):
        return self.get_version()
        
    def get_version(self):
        return self.version
    
    def set_version(self, version):
        self.version = version
       
    def match(self, versionStartIncluding, versionStartExcluding, versionEndIncluding, versionEndExcluding):
        return self.__ge(versionStartIncluding) \
        and self.__gt(versionStartExcluding) \
        and self.__le__(versionEndIncluding) \
        and self.__lt(versionEndExcluding)

## Collection of update functions for the different information sources
class Update:
    # Parse recursively the CPE information from a CVE item. CPE information can be nested. We don't store the logic and only the vulnerable CPE-strings, as we can't match on logic in the query.
    def get_cpe_nodes(cpe_nodes):
        result = []
        
        # Loop all CPE nodes
        for cpe_node in cpe_nodes:
            cpe_matches  = cpe_node["cpe_match"]
            cpe_children = cpe_node["children"]
            # Parse child items (recursive)
            result       += Update.get_cpe_nodes(cpe_children)
            
            # Parse each CPE match
            for cpe_match in cpe_matches:
                vulnerable = cpe_match["vulnerable"]
                # Only store the CPE matches defining a vulnerable software version. 
                if not vulnerable:
                    continue
                
                cpe23Uri    = cpe_match["cpe23Uri"]
                cpe_attr    = split(r'(?<!\\):', cpe23Uri, 6)
                cpe_part    = cpe_attr[2]
                cpe_vendor  = cpe_attr[3]
                cpe_product = cpe_attr[4]
                cpe_version = cpe_attr[5]
                
                versionStartIncluding = get_element(cpe_match, "versionStartIncluding", "")
                versionStartExcluding = get_element(cpe_match, "versionStartExcluding", "")
                versionEndIncluding   = get_element(cpe_match, "versionEndIncluding", "")
                versionEndExcluding   = get_element(cpe_match, "versionEndExcluding", "")
                
                #if "versionStartIncluding" in cpe_match:
                #    versionStartIncluding = cpe_match["versionStartIncluding"]
                #else:
                #    versionStartIncluding = ""
                    
                #if "versionStartExcluding" in cpe_match:
                #    versionStartExcluding = cpe_match["versionStartExcluding"]
                #else:
                #    versionStartExcluding = ""
                
                #if "versionEndIncluding" in cpe_match:
                #    versionEndIncluding = cpe_match["versionEndIncluding"]
                #else:
                #    versionEndIncluding = ""
                    
                #if "versionEndExcluding" in cpe_match:
                #    versionEndExcluding = cpe_match["versionEndExcluding"]
                #else:
                #    versionEndExcluding = ""
                
                cpe_node = {
                    "cpe23Uri": cpe23Uri,
                    "cpe_part": cpe_part,
                    "cpe_vendor": cpe_vendor,
                    "cpe_product": cpe_product,
                    "cpe_version": cpe_version,
                    "versionStartIncluding": versionStartIncluding,
                    "versionStartExcluding": versionStartExcluding,
                    "versionEndIncluding": versionEndIncluding,
                    "versionEndExcluding": versionEndExcluding
                }
                #result.append([cpe23Uri,versionStartIncluding,versionStartExcluding,versionEndIncluding,versionEndExcluding])
                result.append(cpe_node)
                #print("{} \t {: <50}  {} - {}".format(cve_id,cpe23Uri,versionStartIncluding,versionEndExcluding))
        return result

## Collection of search functions for the different information sources
class Search:
    def __init__(self, conn, console, window):
        self.conn = conn
        self.console = Console(console, window)
    
    # Search for CPE string and print the results
    def cpe_print(self, query):
        result = []
        cursor = self.conn.cursor()
        version_matcher = VersionMatcher(split(r'(?<!\\):', query, 6)[5])
        query = query.replace("*", "%")
        query = query.replace("?", "_")
        attributes = split(r'(?<!\\):', query, 6)
        
        sql = "SELECT id, version, versionStartIncluding, versionStartExcluding, versionEndIncluding, versionEndExcluding FROM cpe WHERE part LIKE '{}' AND vendor LIKE '{}' AND product LIKE '{}' AND (version LIKE '{}' OR version='*');".format(attributes[2],attributes[3],attributes[4],attributes[5])
        
        try:
            cursor.execute(sql)
            rows = cursor.fetchall()
            
            for row in rows:
                cve_id                = row[0]
                version               = row[1]
                versionStartIncluding = row[2]
                versionStartExcluding = row[3]
                versionEndIncluding   = row[4]
                versionEndExcluding   = row[5]
                
                print("===================================================================================")
                print("Query for version: {}".format(bla))
                print("CVE ID: {}".format(cve_id))
                print("Match:  {}".format(version_matcher.match(versionStartIncluding, versionStartExcluding, versionEndIncluding, versionEndExcluding)))

                print("| Version | VersionStartIncl | VersionStartExcl | VersionEndIncl | VersionEndExcl |")
                print("|=========|==================|==================|================|================|")
                print("| {:>7} | {:>16} | {:>16} | {:>14} | {:>14} |".format(version, versionStartIncluding, versionStartExcluding, versionEndIncluding, versionEndExcluding))
                print("")
        except Exception as e:
            self.console.write("ERROR - {}".format(e))
        finally:
            return result

    # Search for CPE string and return an array of CVE IDs
    def cpe(self, query):
        result = []
        cursor = self.conn.cursor()

        cpe_attr = split(r'(?<!\\):', query, 6)
        #version     = VersionMatcher(split(r'(?<!\\):', query, 6)[5])
        version_matcher  = VersionMatcher(get_element(cpe_attr, 5, "*"))
        
        # Replace wildcard elements for SQL query
        query    = query.replace("*", "%")
        query    = query.replace("?", "_")
        cpe_attr = split(r'(?<!\\):', query, 6)
        
        cpe_part    = get_element(cpe_attr, 2, "%")
        cpe_vendor  = get_element(cpe_attr, 3, "%")
        cpe_product = get_element(cpe_attr, 4, "%")
        cpe_version = get_element(cpe_attr, 5, "%")
               
        sql = "SELECT id, versionStartIncluding, versionStartExcluding, versionEndIncluding, versionEndExcluding FROM cpe WHERE part LIKE '{}' AND vendor LIKE '{}' AND product LIKE '{}' AND (version LIKE '{}' OR version='*');".format(cpe_part, cpe_vendor, cpe_product, cpe_version)
        
        try:
            cursor.execute(sql)
            rows = cursor.fetchall()
            
            for row in rows:
                cve_id                = row[0]
                versionStartIncluding = row[1]
                versionStartExcluding = row[2]
                versionEndIncluding   = row[3]
                versionEndExcluding   = row[4]
                
                if (versionStartIncluding == "None" and versionStartExcluding == "None" and versionEndIncluding == "None" and versionEndExcluding == "None"):
                    match = True
                else:
                    match = version_matcher.match(versionStartIncluding, versionStartExcluding, versionEndIncluding, versionEndExcluding)
                
                if match:
                    result.append(cve_id)
        except Exception as e:
            self.console.write("ERROR - {}".format(e))
        finally:
            # Deduplicate the CVE list
            result = list(dict.fromkeys(result))
            return result